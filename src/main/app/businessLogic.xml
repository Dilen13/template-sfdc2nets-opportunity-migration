<?xml version="1.0" encoding="UTF-8"?>

<mule xmlns:data-mapper="http://www.mulesoft.org/schema/mule/ee/data-mapper"
	xmlns:netsuite="http://www.mulesoft.org/schema/mule/netsuite"
	xmlns:core="http://www.mulesoft.org/schema/mule/core" xmlns:tracking="http://www.mulesoft.org/schema/mule/ee/tracking"
	xmlns="http://www.mulesoft.org/schema/mule/core" xmlns:doc="http://www.mulesoft.org/schema/mule/documentation"
	xmlns:batch="http://www.mulesoft.org/schema/mule/batch" xmlns:sfdc="http://www.mulesoft.org/schema/mule/sfdc"
	xmlns:smtp="http://www.mulesoft.org/schema/mule/smtp" xmlns:json="http://www.mulesoft.org/schema/mule/json"
	xmlns:spring="http://www.springframework.org/schema/beans" version="EE-3.6.1"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-current.xsd
http://www.mulesoft.org/schema/mule/batch http://www.mulesoft.org/schema/mule/batch/current/mule-batch.xsd
http://www.mulesoft.org/schema/mule/ee/tracking http://www.mulesoft.org/schema/mule/ee/tracking/current/mule-tracking-ee.xsd
http://www.mulesoft.org/schema/mule/json http://www.mulesoft.org/schema/mule/json/current/mule-json.xsd
http://www.mulesoft.org/schema/mule/sfdc http://www.mulesoft.org/schema/mule/sfdc/current/mule-sfdc.xsd
http://www.mulesoft.org/schema/mule/smtp http://www.mulesoft.org/schema/mule/smtp/current/mule-smtp.xsd
http://www.mulesoft.org/schema/mule/netsuite http://www.mulesoft.org/schema/mule/netsuite/current/mule-netsuite.xsd
http://www.mulesoft.org/schema/mule/ee/data-mapper http://www.mulesoft.org/schema/mule/ee/data-mapper/current/mule-data-mapper.xsd">
	<data-mapper:config name="Opportunity_To_OPPORTUNITY"
		transformationGraphPath="opportunity_to_opportunity.grf" doc:name="Opportunity_To_OPPORTUNITY" />

	<batch:job name="migrateOpportunitiesBatch">
		<batch:threading-profile poolExhaustedAction="WAIT" />
		<batch:input>
			<sfdc:query config-ref="Salesforce"
				query="dsql:SELECT Id, LastModifiedDate, Name, Amount, StageName, Probability, CloseDate, Account.Id, Account.Name, Account.Industry, Account.NumberOfEmployees FROM Opportunity WHERE Amount &gt; 120000 and Account.Id &lt;&gt; null"
				fetchSize="${page.size}" doc:name="query Opportunities from Salesforce" />
		</batch:input>
		<batch:process-records>
			<batch:step name="getOpportunityInNetsuiteStep">
				<enricher source="#[payload]" target="#[recordVars['opportunityInNetsuite']]"
					doc:name="store result in record var 'opportunityInNetsuite'">
					<processor-chain doc:name="Processor Chain">
						<netsuite:query-records config-ref="Netsuite"
							query="dsql:SELECT department,entity,entityStatus,externalId,internalId,lastModifiedDate,leadSource,partner,status,
subsidiary,title,tranDate,tranId,expectedCloseDate,probability
 FROM OPPORTUNITY where externalId = '#[payload['Id']]'"
							doc:name="query Opportunity in Netsuite" />
						<expression-component doc:name="retrieve Opportunity object"><![CDATA[java.util.HashMap opportunity;

if (payload.hasNext()){
	opportunity = payload.next();
}

payload = opportunity;]]></expression-component>
					</processor-chain>
				</enricher>
			</batch:step>
			<batch:step name="getCustomerIExists">
				<enricher source="#[payload]" target="#[recordVars['customerInNetsuite']]"
					doc:name="store result in customerInNetsuite">
					<processor-chain doc:name="Processor Chain">
						<netsuite:query-records config-ref="Netsuite"
							query="dsql:SELECT companyName,entityId,entityStatus,externalId,internalId FROM CUSTOMER WHERE companyName = '#[payload['Account']['Name']]'"
							doc:name="query Customer in Netsuite" />
						<expression-component doc:name="retrieve Customer object"><![CDATA[java.util.HashMap customer;

if (payload.hasNext()){
	customer = payload.next();
}

payload = customer;]]></expression-component>
					</processor-chain>
				</enricher>
			</batch:step>
			<batch:step name="createCustomerIfDoesNotExist"
				accept-expression="#[recordVars['customerInNetsuite'] is NullPayload]">
				<enricher target="#[recordVars['customerInNetsuite']]"
					doc:name="store result in customerInNetsuite">
					<processor-chain doc:name="Processor Chain">
						<expression-component doc:name="Add subsidiary to payload"><![CDATA[import com.netsuite.webservices.platform.core_2014_1.RecordRef;
import com.netsuite.webservices.platform.core_2014_1.types.RecordType;

RecordRef subsidiaryRef = new RecordRef();
subsidiaryRef.setType(RecordType.SUBSIDIARY);
subsidiaryRef.setInternalId('${nets.customer.subsidiary.internalId}');

payload.put("subsidiary", subsidiaryRef);]]></expression-component>
						<netsuite:add-record config-ref="Netsuite"
							recordType="CUSTOMER" doc:name="create Customer in Netsuite">
							<netsuite:attributes>
								<netsuite:attribute key="companyName">#[payload['Account']['Name']]</netsuite:attribute>
								<netsuite:attribute key="subsidiary">#[payload['subsidiary']]</netsuite:attribute>
							</netsuite:attributes>
						</netsuite:add-record>
						<logger
							message="New Customer created in Netsuite: #[payload.getInternalId()]"
							level="INFO" doc:name="log created Customer" />
						<netsuite:query-records config-ref="Netsuite"
							query="dsql:SELECT companyName,entityId,entityStatus,externalId,internalId FROM CUSTOMER WHERE internalId = '#[payload.getInternalId()]'"
							doc:name="query created Customer in Netsuite" />
						<expression-component doc:name="retrieve created Customer object"><![CDATA[java.util.HashMap customer;

if (payload.hasNext()){
	customer = payload.next();
}

payload = customer;]]></expression-component>
					</processor-chain>
				</enricher>
			</batch:step>
			<batch:step name="upsertOpportunitiesInNetsuiteStep"
				accept-expression="!(payload is NullPayload)">
				<data-mapper:transform config-ref="Opportunity_To_OPPORTUNITY"
					doc:name="Opportunity To OPPORTUNITY">
					<data-mapper:input-arguments>
						<data-mapper:input-argument key="defaultStatus">${nets.default.status}</data-mapper:input-argument>
					</data-mapper:input-arguments>
				</data-mapper:transform>
				<expression-component doc:name="Add customer and customer status to payload"><![CDATA[import com.netsuite.webservices.platform.core_2014_1.RecordRef;
import com.netsuite.webservices.platform.core_2014_1.types.RecordType;

RecordRef entityRef = new RecordRef();
entityRef.setType(RecordType.CUSTOMER);
entityRef.setInternalId(recordVars['customerInNetsuite']['internalId']);

RecordRef entityStatusRef = recordVars['customerInNetsuite']['entityStatus'];
entityStatusRef.setType(RecordType.CUSTOMER_STATUS);

payload.put("entity", entityRef);
payload.put("entityStatus", entityStatusRef);]]></expression-component>

				<netsuite:upsert-record config-ref="Netsuite"
					recordType="OPPORTUNITY" doc:name="upsert Opportunities in Netsuite">
					<netsuite:attributes ref="#[payload]">

					</netsuite:attributes>
				</netsuite:upsert-record>
				<logger
					message="Upserted opportunity with internal ID: #[payload.getInternalId()] "
					level="INFO" doc:name="log Upsert result" />
			</batch:step>

		</batch:process-records>
		<batch:on-complete>
			<scatter-gather doc:name="All">
				<processor-chain>
					<json:object-to-json-transformer
						doc:name="transform BatchJobInstance to JSON" />
					<logger message="Migration process has finished: #[payload]"
						level="INFO" doc:name="log 'Migration process has finished'" />
				</processor-chain>
				<processor-chain>
					<json:object-to-json-transformer
						doc:name="transform BatchJobInstance to JSON" />
					<smtp:outbound-endpoint host="${smtp.host}"
						port="${smtp.port}" user="${smtp.user}" password="${smtp.password}"
						to="${mail.to}" from="${mail.from}" subject="${mail.subject}"
						responseTimeout="10000" connector-ref="gmailConnector" doc:name="send mail" />
				</processor-chain>
			</scatter-gather>
		</batch:on-complete>
	</batch:job>

	<flow name="mainFlow" processingStrategy="synchronous"
		doc:description="This flow is the entry point to the Anypoint Template business logic.

This flow should control the direction of the application, and it should be called by the different endpoints that your Anypoint Template exposes to trigger it.

">
		<batch:execute name="migrateOpportunitiesBatch"
			doc:name="trigger migrateOpportunitiesBatch" />
		<exception-strategy ref="defaultChoiceExceptionStrategy"
			doc:name="catch Exception and call defaultChoiceExceptionStrategy" />
	</flow>

</mule>
